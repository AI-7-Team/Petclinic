import io
import os
import torch
from PIL import Image
from flask import Flask, render_template, request, jsonify
import torch.nn.functional as F
from torchvision import transforms
import base64
import datetime
from AI.model import build_resnet50
import google.generativeai as genai  # 변경: google.generativeai 라이브러리 임포트
from dotenv import load_dotenv

# --- 1. 초기 설정 및 환경변수 로딩 ---
load_dotenv()  # .env 파일에서 환경변수 로드
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"  # 간결하게 수정
print(f"DEVICE = {DEVICE}")
app = Flask(__name__, static_url_path='/static')

# --- Gemini API 키 로딩 및 설정 (변경) ---
api_key = os.environ.get("GOOGLE_API_KEY")  # .env 파일의 키 이름을 GOOGLE_API_KEY로 변경 권장
if not api_key:
    raise ValueError("GOOGLE_API_KEY 환경변수가 설정되지 않았습니다.")

genai.configure(api_key=api_key)  # Gemini 클라이언트 설정
print("✅ Google Gemini API 키 로딩 및 설정 완료!")

# --- 2. 데이터 및 모델 설정 (기존과 동일) ---

# 각 증상별 설명 데이터
descriptions = {
    'A4': {
        'title': '농포 (Pustule) / 여드름 (Acne)',
        'description': '농포는 고름(농)을 포함하는 작은 융기입니다. 여드름의 한 형태로 나타날 수 있으며, 모낭의 염증이나 감염으로 인해 발생합니다. 반려동물의 경우 박테리아 감염의 신호일 수 있습니다.',
        'image': '/static/images/result_sample_pustule.png'
    },
    'A5': {
        'title': '미란 (Erosion) / 궤양 (Ulcer)',
        'description': '미란은 피부의 가장 바깥층(표피)만 얕게 손상된 상태로, 보통 흉터 없이 치유됩니다. 궤양은 표피를 넘어 진피까지 깊게 손상된 상태로, 치유 후 흉터가 남을 수 있습니다. 지속적인 핥기, 감염, 화상 등 다양한 원인으로 발생할 수 있습니다.',
        'image': '/static/images/result_sample_eu.png'
    },
    'A6': {
        'title': '결절 (Nodule) / 종괴 (Tumor)',
        'description': '결절은 피부 속이나 아래에 생긴 단단한 덩어리(보통 1cm 미만)를 말합니다. 종괴는 결절보다 더 큰 덩어리를 의미하며, 양성일 수도 악성일 수도 있으므로 반드시 수의사의 정밀 진단이 필요합니다. 염증, 감염, 종양 등 심각한 원인의 가능성이 있습니다.',
        'image': '/static/images/result_sample_nt.png'
    },
    'A7': {
        'title': '무증상',
        'description': '탐지된 증상으로서는 발견된 것이 없습니다.',
        'image': '/static/images/result_sample_nt.png'
    }
}

# ResNet 모델 로딩
MODEL_PATH = 'models_train/resnet50_lesion.pth'

# 1. 체크포인트 파일을 안전하게 "한 번만" 불러옵니다.
checkpoint = torch.load(MODEL_PATH, map_location=DEVICE, weights_only=True)

# 2. 위에서 불러온 checkpoint 변수를 사용하여 클래스 정보를 설정합니다.
class_to_idx = checkpoint['class_to_idx']
idx_to_class = {v: k for k, v in class_to_idx.items()}

# 3. 클래스 정보에 따라 모델 구조를 생성합니다.
model = build_resnet50(num_classes=len(class_to_idx))

# 4. "다시 불러올 필요 없이" 동일한 checkpoint 변수에서 모델 가중치를 로드합니다.
model.load_state_dict(checkpoint['model'])
model = model.to(DEVICE)
model.eval()

transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])


# --- 3. 라우트(Routes) 설정 ---

@app.route('/')
def index():
    return render_template("about.html")


@app.route('/about')
def about():
    return render_template("about.html")


@app.route('/detect', methods=['GET', 'POST'])
def detect():
    if request.method == 'POST':
        file = request.files.get('file')
        if not file:
            return render_template("detect.html", error="이미지 파일을 선택해주세요.")

        try:
            file_bytes = file.read()
            img = Image.open(io.BytesIO(file_bytes)).convert('RGB')

            # Base64 인코딩 부분은 기존과 동일
            buffered = io.BytesIO(file_bytes)
            encoded_img_data = base64.b64encode(buffered.getvalue()).decode('utf-8')

            img_tensor = transform(img).unsqueeze(0).to(DEVICE)

            with torch.no_grad():
                output = model(img_tensor)
                probabilities = F.softmax(output, dim=1)
                predicted_idx = torch.argmax(probabilities, dim=1).item()

            predicted_class = idx_to_class[predicted_idx]
            confidence = probabilities[0][predicted_idx].item() * 100

            result_description = descriptions.get(predicted_class, {
                'title': '알 수 없는 증상',
                'description': '데이터베이스에 없는 증상입니다.',
                'image': ''
            })
            # --- Gemini API 호출 (핵심 변경 부분) ---
            gemini_response = ""  # 변수 초기화

            predicted_class_name = result_description["title"]

            if predicted_class_name == "A7":  # 건강(A7) 클래스가 있다면
                gpt_message = "정상 소견으로 보입니다. 특별한 증상이 없다면 안심하셔도 좋습니다."

            else:
                if predicted_class_name == "A4":
                    predicted_class_name = "농포_여드름"
                if predicted_class_name == "A5":
                    predicted_class_name = "미란_궤양"
                if predicted_class_name == "A6":
                    predicted_class_name = "결절_종괴"
                # 1. 프롬프트 정의
                prompt = f"""당신은 반려동물 피부질환 AI 검사원입니다. 보호자가 이해하기 쉽도록 친절한 말투를 사용해주세요.

                        질병명: {predicted_class_name}

                        위 질병에 대해 다음 항목을 포함하여 200자 내외로 설명해주세요.
                        1. 출력은 포맷 없이 일반 텍스트로만 작성해줘
                        2. 마크다운, HTML, 특수문자(*,, ~ 등)를 사용하지 말고, 강조 없이 자연스러운 문장만 보여줘
                        3. 예상 원인
                        4. 가정에서의 관리법
                        5. 동물병원 방문 권장 여부 및 이유
                        """

                # 2. 모델 및 생성 설정 정의
                generation_config = {
                    "temperature": 0.7,
                    "max_output_tokens": 300,
                }

                # 3. 모델 생성 및 콘텐츠 생성
                gemini_model = genai.GenerativeModel(model_name="gemini-2.0-flash")
                response = gemini_model.generate_content(prompt, generation_config=generation_config)

                # 4. 응답 텍스트 추출
                gemini_response = response.text
                print(gemini_response)

            # 결과 반환
            return render_template('result.html',
                                   prediction=predicted_class,
                                   confidence=f"{confidence:.2f}%",
                                   img_data=encoded_img_data,
                                   description_data=result_description,
                                   gpt_response=gemini_response
                                   )

        except Exception as e:
            print(f"Error during prediction: {e}")
            return render_template("detect.html", error="분석 중 오류가 발생했습니다.")

    return render_template("detect.html")


# --- 나머지 라우트 및 앱 실행 (기존과 동일) ---

# 커뮤니티 라우트
@app.route('/community')
def community():
    """커뮤니티 게시글 목록을 보여주는 페이지입니다."""
    dummy_posts = [
        {'id': 1, 'title': '첫 번째 글입니다', 'author': '관리자', 'create_date': datetime.datetime(2025, 9, 21), 'views': 15},
        {'id': 2, 'title': 'Flask 게시판 만들기', 'author': '김코딩', 'create_date': datetime.datetime(2025, 9, 20),
         'views': 42},
    ]
    return render_template('community.html', posts=dummy_posts)


@app.route('/post/<int:post_id>/')
def detail(post_id):
    """개별 게시글의 상세 내용을 보여주는 페이지입니다."""
    return f"게시글 상세 페이지입니다. (ID: {post_id})"


@app.route('/post/create/')
def create():
    """새로운 게시글을 작성하는 페이지를 보여줍니다."""
    return "게시글 작성 페이지입니다."


# 병원 지도 및 404 에러 핸들러
@app.route('/hospital')
def hospital():
    return render_template("hospital.html")


@app.errorhandler(404)
def page_not_found(error):
    return render_template('404.html'), 404


# --- 4. 앱 실행 ---
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)